package install

import (
	"fmt"
	"os"

	"encoding/json"
	"path/filepath"
	"github.com/lazypwny751/gibi/pkg/config"
	"github.com/lazypwny751/gibi/pkg/base"

	// git "github.com/go-git/go-git/v5"
)

func installPackage(pkg config.Config, src string) error {
	if src == "" {
		return fmt.Errorf("source path is required")
	}

	if pkg.Package == "" {
		return fmt.Errorf("package name is required")
	}

	if pkg.Version == "" {
		return fmt.Errorf("package version is required")
	}

	if pkg.Build == "" {
		return fmt.Errorf("package build information is required")
	}
	
	if pkg.Author == "" {
		pkg.Author = "unknown"
	}

	if pkg.Description == "" {
		pkg.Description = "No description provided."
	}

	if _, err := os.Stat(base.CacheDir+"/"+pkg.Package); os.IsNotExist(err) {
		err := os.MkdirAll(base.CacheDir+"/"+pkg.Package, 0755)
		if err != nil {
			return fmt.Errorf("failed to create package directory: %w", err)
		}
	}

	cacheDir := base.CacheDir + "/" + pkg.Package
	if _, err := os.Stat(cacheDir + "/config.json"); os.IsNotExist(err) {
		err := os.MkdirAll(cacheDir, 0755)
		if err != nil {
			return fmt.Errorf("failed to create cache directory: %w", err)
		}
	}

	// Generate the base package configuration file.
	jsonData, err := json.MarshalIndent(pkg, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal package config: %w", err)
	}

	// Clean package build directory if it exists.
	gibiBuildDir := filepath.Join(cacheDir, "build")
	if _, err := os.Stat(gibiBuildDir); !os.IsNotExist(err) {
		err := os.RemoveAll(gibiBuildDir)
		if err != nil {
			return fmt.Errorf("failed to remove existing build directory: %w", err)
		}
	}
	
	// Create the package build directory.
	if _, err := os.Stat(gibiBuildDir); os.IsNotExist(err) {
		err := os.MkdirAll(gibiBuildDir, 0755)
		if err != nil {
			return fmt.Errorf("failed to create build directory: %w", err)
		}
	}

	configFilePath := filepath.Join(cacheDir, "config.json")
	if err := os.WriteFile(configFilePath, jsonData, 0644); err != nil {
		return fmt.Errorf("failed to write package config to file: %w", err)
	}

	buildHeader := "#!/bin/sh\n\n# Build script for " + pkg.Package + "\n# please do not edit this file, it is auto-generated by Gibi\n\nset -e\n\nreadonly GIBI_BUILD=\"" + gibiBuildDir + "\"\nreadonly GIBI_BIN=\"" + base.BinDir + "\"\n\n"
	buildScriptPath := filepath.Join(cacheDir, "build.sh")
	if err := os.WriteFile(buildScriptPath, []byte(buildHeader+pkg.Build), 0755); err != nil {
		return fmt.Errorf("failed to write build script: %w", err)
	}

	return nil
}

// InstallPackages installs the specified packages based on the provided configuration.
func InstallPackages(pkgs []string) error {
	if len(pkgs) == 0 {
		return fmt.Errorf("no packages specified for installation")
	}

	for _, pkg := range pkgs {
		// fmt.Printf("Selecting given parameter: %s\n", pkg) // Debugging line to show the package being processed
		
		if config.IsPath(pkg) {
			// If the package is a local path, check if it exists
			if _, err := os.Stat(pkg); !os.IsNotExist(err) {
				conf, _ := config.LoadConfig(pkg)
				fmt.Printf("Installing package from local path: %s\n", conf.Package)

				if err := installPackage(*conf, filepath.Dir(pkg)); err != nil {
					return fmt.Errorf("failed to install package from %s: %w", pkg, err)
				}
			} else {
				return fmt.Errorf("local path does not exist: %s", pkg)
			}
		} else if config.SetUrlType(pkg) != config.None {
			// If the package is a URL, handle it accordingly
			fmt.Printf("Installing from URL: %s\n", pkg)
		} else {
			// If the package is neither a valid path nor a URL, return an error
			return fmt.Errorf("invalid package format: %s", pkg)
		}
	}

	return nil
}

func UninstallPackages(pkgs []string) error {
	if len(pkgs) == 0 {
		return fmt.Errorf("no packages specified for uninstallation")
	}

	for _, pkg := range pkgs {
		fmt.Printf("Uninstalling package: %s\n", pkg)
	}

	return nil
}