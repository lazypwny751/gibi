package build

import (
	"fmt"
	"os"
	"strings"
	"os/exec"
	"path/filepath"
	"encoding/json"

	"github.com/lazypwny751/gibi/pkg/base"
	"github.com/lazypwny751/gibi/pkg/config"
	"github.com/lazypwny751/gibi/pkg/utils"
)

func BuildPackage(pkg config.Config, src string) error {
	// Check required fields in the package configuration.
	if src == "" {
		return fmt.Errorf("source path is required")
	}

	if pkg.Package == "" {
		return fmt.Errorf("package name is required")
	}

	if pkg.Version == "" {
		return fmt.Errorf("package version is required")
	}

	if pkg.Build == "" {
		return fmt.Errorf("package build information is required")
	}
	
	if pkg.Author == "" {
		pkg.Author = "unknown"
	}

	if pkg.Description == "" {
		pkg.Description = "No description provided."
	}

	// Create a cache directory for the package if it does not exist.
	cacheDir := base.CacheDir + "/" + pkg.Package
	if _, err := os.Stat(cacheDir); os.IsNotExist(err) {
		err := os.MkdirAll(cacheDir, 0755)
		if err != nil {
			return fmt.Errorf("failed to create cache directory: %w", err)
		}
	}

	// Generate the base package configuration file.
	jsonData, err := json.MarshalIndent(pkg, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal package config: %w", err)
	}

	// Clean package build directory if it exists.
	gibiBuildDir := filepath.Join(cacheDir, "build")
	if _, err := os.Stat(gibiBuildDir); !os.IsNotExist(err) {
		err := os.RemoveAll(gibiBuildDir)
		if err != nil {
			return fmt.Errorf("failed to remove existing build directory: %w", err)
		}
	}
	
	// Create the package build directory.
	if _, err := os.Stat(gibiBuildDir); os.IsNotExist(err) {
		err := os.MkdirAll(gibiBuildDir, 0755)
		if err != nil {
			return fmt.Errorf("failed to create build directory: %w", err)
		}
	}

	// Write the package configuration to a JSON file.
	configFilePath := filepath.Join(cacheDir, "config.json")
	if err := os.WriteFile(configFilePath, jsonData, 0644); err != nil {
		return fmt.Errorf("failed to write package config to file: %w", err)
	}

	// Write the build script to the package build directory.
	buildHeader := "#!/bin/sh\n\n# Build script for " + pkg.Package + "\n# please do not edit this file, it is auto-generated by Gibi\n\nset -e\n\nreadonly GIBI_BUILD=\"" + gibiBuildDir + "\"\nreadonly GIBI_BIN=\"" + base.BinDir + "\"\n\n"
	buildScriptPath := filepath.Join(cacheDir, "build.sh")
	if err := os.WriteFile(buildScriptPath, []byte(buildHeader+pkg.Build), 0755); err != nil {
		return fmt.Errorf("failed to write build script: %w", err)
	}

	// Resolve the source path to its real path.
	real, err := filepath.EvalSymlinks(src)
	if err != nil {
		return fmt.Errorf("failed to resolve source path: %w", err)
	}

	// Ensure the real path is absolute.
	real, err = filepath.Abs(real)
	if err != nil {
		return fmt.Errorf("failed to get absolute path of source: %w", err)
	}

	// Create a symlink to the source directory in the cache directory.
	if _, err := os.Stat(filepath.Join(cacheDir, "source")); os.IsNotExist(err) {
		err := os.Symlink(real, filepath.Join(cacheDir, "source"))
		if err != nil {
			return fmt.Errorf("failed to create source symlink: %w", err)
		}
	} else {
		if err := os.Remove(filepath.Join(cacheDir, "source")); err != nil {
			return fmt.Errorf("failed to remove existing source symlink: %w", err)
		}
		err := os.Symlink(real, filepath.Join(cacheDir, "source"))
		if err != nil {
			return fmt.Errorf("failed to create source symlink: %w", err)
		}
	}

	// Create a link to the build script in the source directory.
	gibiBuildScript := filepath.Join(filepath.Join(cacheDir, "source"), "gibi-build.sh")
	for {
		if _, err := os.Stat(gibiBuildScript); os.IsNotExist(err) {
			// Create a link to the build script in the source directory.
			if err := os.Link(buildScriptPath, gibiBuildScript); err != nil {
				return fmt.Errorf("failed to create link to build script: %w", err)
			}
			break
		} else {
			gibiBuildScript = filepath.Join(filepath.Join(cacheDir, "source"), "gibi-build_" + utils.RandString(8) + ".sh")
		}
	}

	// Execute the build script if it exists.
	if _, err := os.Stat(gibiBuildScript); !os.IsNotExist(err) {
		if err := exec.Command("sh", gibiBuildScript).Run(); err != nil {
			return fmt.Errorf("failed to execute build script: %w", err)
		}
	} else {
		return fmt.Errorf("build script does not exist: %s", gibiBuildScript)
	}

	// Get the list of entries in the build directory.
	entries := []string{}
	if _, err := os.Stat(gibiBuildDir); !os.IsNotExist(err) {
		err := filepath.Walk(gibiBuildDir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return fmt.Errorf("error walking through build directory: %w", err)
			}

			relPath := strings.TrimPrefix(path, gibiBuildDir)
			if relPath != "" {
				if len(relPath) > 0 && relPath[0] == '/' {
					entries = append(entries, relPath[1:])
				} else {
					entries = append(entries, relPath)
				}
			}

			return nil
		})
		if err != nil {
			return fmt.Errorf("error walking through build directory: %w", err)
		}
	} else {
		return fmt.Errorf("build directory does not exist: %s", gibiBuildDir)
	}

	// Write the entries to a file in the cache directory.
	entriesAsJson, err := json.MarshalIndent(entries, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal entries to JSON: %w", err)
	}

	// Create the entries file in the cache directory.
	entriesFilePath := filepath.Join(cacheDir, "entries.json")
	if err := os.WriteFile(entriesFilePath, entriesAsJson, 0644); err != nil {
		return fmt.Errorf("failed to write entries to file: %w", err)
	}

	return nil
}
