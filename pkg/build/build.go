package build

import (
	"fmt"
	"os"
	"strings"
	"os/exec"
	"path/filepath"

	"github.com/lazypwny751/gibi/pkg/base"
	"github.com/lazypwny751/gibi/pkg/config"
	"github.com/lazypwny751/gibi/pkg/utils"
)

type BuildConfig struct {
	Package     string `json:"package"`
	Version     string `json:"version"`
	Build       string `json:"build"`
	Author      string `json:"author"`
	Description string `json:"description"`
	CacheDir   string `json:"cache_dir"`
	BuildDir    string `json:"build_dir"`
	BuildScript string `json:"build_script"`
	SourcePath  string `json:"source_path"`
	Entries     []string `json:"entries"`
	// Configs   []string `json:"configs" // Additional configurations for the package, if any.
}

// BuildPackage builds the specified package based on the provided configuration and source path.
// It creates necessary directories, writes configuration files, and executes the build script.
func BuildPackage(pkg config.Config, src string) (BuildConfig, error) {
	build_config := BuildConfig{}

	// Check required fields in the package configuration.
	if src == "" {
		return build_config, fmt.Errorf("source path is required")
	}

	if pkg.Package == "" {
		return build_config, fmt.Errorf("package name is required")
	}

	if pkg.Version == "" {
		return build_config, fmt.Errorf("package version is required")
	}

	if pkg.Build == "" {
		return build_config, fmt.Errorf("package build information is required")
	}
	
	if pkg.Author == "" {
		pkg.Author = "unknown"
	}

	if pkg.Description == "" {
		pkg.Description = "No description provided."
	}

	// Create a cache directory for the package if it does not exist.
	cacheDir := base.CacheDir + "/" + pkg.Package
	if _, err := os.Stat(cacheDir); os.IsNotExist(err) {
		err := os.MkdirAll(cacheDir, 0755)
		if err != nil {
			return build_config, fmt.Errorf("failed to create cache directory: %w", err)
		}
	}

	// Clean package build directory if it exists.
	gibiBuildDir := filepath.Join(cacheDir, "build")
	if _, err := os.Stat(gibiBuildDir); !os.IsNotExist(err) {
		err := os.RemoveAll(gibiBuildDir)
		if err != nil {
			return build_config, fmt.Errorf("failed to remove existing build directory: %w", err)
		}
	}
	
	// Write the build script to the package build directory.
	buildHeader := "#!/bin/sh\n\n# Build script for " + pkg.Package + "\n# please do not edit this file, it is auto-generated by Gibi\n\nset -e\n\nreadonly GIBI_BUILD=\"" + gibiBuildDir + "\"\nreadonly GIBI_BIN=\"" + base.BinDir + "\"\n\n"
	buildScriptPath := filepath.Join(cacheDir, "build.sh")
	if err := os.WriteFile(buildScriptPath, []byte(buildHeader+pkg.Build), 0755); err != nil {
		return build_config, fmt.Errorf("failed to write build script: %w", err)
	}

	// Resolve the source path to its real path.
	real, err := filepath.EvalSymlinks(src)
	if err != nil {
		return build_config, fmt.Errorf("failed to resolve source path: %w", err)
	}

	// Ensure the real path is absolute.
	real, err = filepath.Abs(real)
	if err != nil {
		return build_config, fmt.Errorf("failed to get absolute path of source: %w", err)
	}

	// Create a symlink to the source directory in the cache directory.
	_ = os.Remove(filepath.Join(cacheDir, "source")) // Remove existing symlink if it exists
	if err := os.Symlink(real, filepath.Join(cacheDir, "source")); err != nil {
		return build_config, fmt.Errorf("failed to create symlink to source: %w", err)
	}

	// Create a link to the build script in the source directory.
	gibiBuildScript := filepath.Join(filepath.Join(cacheDir, "source"), "gibi-build.sh")
	for {
		if _, err := os.Stat(gibiBuildScript); os.IsNotExist(err) {
			// Create a link to the build script in the source directory.
			if err := os.Link(buildScriptPath, gibiBuildScript); err != nil {
				return build_config, fmt.Errorf("failed to create link to build script: %w", err)
			}
			break
		} else {
			gibiBuildScript = filepath.Join(filepath.Join(cacheDir, "source"), "gibi-build_" + utils.RandString(8) + ".sh")
		}
	}

	// Execute the build script if it exists.
	if _, err := os.Stat(gibiBuildScript); !os.IsNotExist(err) {
		if err := exec.Command("sh", gibiBuildScript).Run(); err != nil {
			return build_config, fmt.Errorf("failed to execute build script: %w", err)
		}
	} else {
		return build_config, fmt.Errorf("build script does not exist: %s", gibiBuildScript)
	}

	// Get the list of entries in the build directory.
	entries := []string{}
	if _, err := os.Stat(gibiBuildDir); !os.IsNotExist(err) {
		err := filepath.Walk(gibiBuildDir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return fmt.Errorf("error walking through build directory: %w", err)
			}

			relPath := strings.TrimPrefix(path, gibiBuildDir)
			if relPath != "" {
				if len(relPath) > 0 && relPath[0] == '/' {
					entries = append(entries, relPath[1:])
				} else {
					entries = append(entries, relPath)
				}
			}

			return  nil
		})
		if err != nil {
			return build_config, fmt.Errorf("error walking through build directory: %w", err)
		}
	} else {
		return build_config, fmt.Errorf("build directory does not exist: %s", gibiBuildDir)
	}

	// Create the build configuration.
	// This includes the package name, version, author, description, build script, and entries.
	build_config = BuildConfig{
		Package:     pkg.Package,
		Version:     pkg.Version,
		Author:      pkg.Author,
		Description: pkg.Description,
		Build:       pkg.Build,
		CacheDir:    cacheDir,
		BuildDir:    gibiBuildDir,
		BuildScript: buildScriptPath,
		SourcePath:  real,
		Entries:     entries,
	}

	// return the build configuration.
	return build_config, nil
}